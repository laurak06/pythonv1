'============SOLID============='
# SOLID - это аббревиатура для набора принципов проектирования,
# созданных для разработки ПО при помощи ОО-языков

# Принципы SOLID напревлены на содействие разработки более простого надежного
# и обновляемого когда

# S (SRP)
# 1. Single Responsibility Principle
# Принцип единственной Обязанности
# Он требует, чтобы 1 класс выполнял 1 работу (то-есть не надо создавать огромный
# класс, который делает все

# O (OCP)
# 2. Open-Closed Principle
# Принцип открытости/закрытости
# Программные сущности (классы, модули, функции) должны быть открыты
# для расширения, но закрыты для модификаций

# L (LSP)
# 3. Liskov Substitution Principle
# Принцип Подстановки Лисков
# Главная идея в то, что для любого класса клиент должен иметь
# возможность использовать любой подкласс этого класса, не замечая разницы между ними.
# Это означает, что клиент полностью изолирован и не подозревает об изменениях
# в иерархии классов

# I (ISP)
# 4.Interface Segregation Principle

# Принцип разделения интерфейсов

# Создавайте тонкие интерфейсы, которые ориентированы на клиента.
# Клиент не должен зависеть от интерфейсов (или же методов
# которые не используются). Этот принцип устраняет недостатки реализации
# больших интерфейсов

class Creature:
    def __init__(self, name):
        self.name = name

    def swim(self):
        ...

    def walk(self):
        ...

    def talk(self):
        ...


class Human(Creature):
    def __init__(self, name):
        super().__init__(name)

    def swim(self):
        print(f'{self.name} - умеет плавать')

    def walk(self):
        print(f'{self.name} - умеет ходить')

    def talk(self):
        print(f'{self.name} - умеет говорить')


class Fish(Creature):
    def __init__(self, name):
        super().__init__(name)


# D (DIP)
# Dependency Inversion Principle
# Принцип инверсии зависимостей
# Зависимость должна быть от абстракций, а не от конкретики
# Модули верхних уровней не должны зависеть от модулей
# нижних уровней. Классы и верхних, и нижних должны зависеть
# от одних и тех же абстракций. Абстракции не должны зависеть
# от деталей. Детали должны зависеть от абстракций


